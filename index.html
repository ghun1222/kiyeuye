<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Galaxy & Luvu</title>
<style>
    body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: 'Arial', sans-serif;
    }
    canvas { display: block; }

    /* UI chá»¯ Ä‘Ã¨ lÃªn */
    #ui-layer {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        color: white;
        pointer-events: none;
        z-index: 10;
        text-shadow: 0 0 10px rgba(255, 105, 180, 0.8);
    }
    #ui-layer h1 {
        font-size: 3rem;
        margin: 0;
        font-weight: 300;
        letter-spacing: 5px;
        animation: fade 3s infinite alternate;
    }
    #ui-layer p {
        font-size: 1.2rem;
        opacity: 0.8;
        margin-top: 10px;
    }
    @keyframes fade { from { opacity: 0.5; } to { opacity: 1; } }
    @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@700&display=swap');
</style>
</head>
<body>

<div id="ui-layer">
    <h1>Xoay Ä‘i nÃ </h1>
    <p></p>
</div>

<!-- SoundCloud Embed -->
<iframe id="scPlayer" 
    width="0" height="0" 
    scrolling="no" frameborder="no" allow="autoplay"
    src="https://w.soundcloud.com/player/?url=https%3A//soundcloud.com/1708-ph-m-h-u-vi-t/phep-mau-dan-ca-go-ost-maydays-ft-minh-toc&auto_play=false&loop=true&hide_related=true&show_comments=false&show_user=false&show_reposts=false&visual=false">
</iframe>

<script>
document.addEventListener("click", () => {
    const iframe = document.getElementById("scPlayer");
    // báº­t nháº¡c vÃ  loop luÃ´n
    iframe.src = iframe.src.replace("auto_play=false", "auto_play=true");
}, { once: true });
</script>

<!-- THREE.JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
// --- Cáº¤U HÃŒNH GALAXY ---
const galaxyParams = { count: 50000, size: 0.015, radius: 5, branches: 3, spin: 1, randomness: 0.2, randomnessPower: 3, insideColor: '#ff6030', outsideColor: '#1b3984' };

// --- TEXTS FLOATING ---
const messages = [
    { text: "Äi ká»‰ yáº¿u mphuong nhÃ¡ â¤ï¸", color: "#FFD700", size: 1.25, isHeart: false },
    { text: "YÃªu láº¯m láº¯m", color: "#FF69B4", size: 1, isHeart: false },
    { text: "Let's capture the memories", color: "#ebb538", size: 1, isHeart: false },
    { text: "You are the best yay", color: "#00FFFF", size: 1, isHeart: false },
    { text: "MÃ£i bÃªn nhau nhÃ¡", color: "#FFFFFF", size: 1, isHeart: false },
    { text: "14/12!!", color: "#53f222", size: 1, isHeart: false },
    { text: "ðŸ’–", color: "#FF1493", size: 1.5, isHeart: true },
    { text: "âœ¨", color: "#FFFF00", size: 1.0, isHeart: true },
    { text: "ðŸ’•", color: "#FF69B4", size: 1.5, isHeart: true },
    { text: "â£ï¸", color: "#FF0000", size: 1.2, isHeart: true }
];
const PARTICLE_COUNT = 150;
const FONT_FAMILY = 'Montserrat, sans-serif';

// --- SCENE ---
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.03);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(3, 3, 10);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.5;

// --- GALAXY ---
let galaxyGeometry, galaxyMaterial, galaxyPoints;
const generateGalaxy = () => {
    if (galaxyPoints) { galaxyGeometry.dispose(); galaxyMaterial.dispose(); scene.remove(galaxyPoints); }

    galaxyGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(galaxyParams.count * 3);
    const colors = new Float32Array(galaxyParams.count * 3);
    const colorInside = new THREE.Color(galaxyParams.insideColor);
    const colorOutside = new THREE.Color(galaxyParams.outsideColor);

    for (let i = 0; i < galaxyParams.count; i++) {
        const i3 = i * 3;
        const radius = Math.random() * galaxyParams.radius;
        const spinAngle = radius * galaxyParams.spin;
        const branchAngle = (i % galaxyParams.branches) / galaxyParams.branches * Math.PI * 2;
        const randomX = Math.pow(Math.random(), galaxyParams.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * galaxyParams.randomness * radius;
        const randomY = Math.pow(Math.random(), galaxyParams.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * galaxyParams.randomness * radius;
        const randomZ = Math.pow(Math.random(), galaxyParams.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * galaxyParams.randomness * radius;

        positions[i3] = Math.cos(branchAngle + spinAngle) * radius + randomX;
        positions[i3 + 1] = randomY;
        positions[i3 + 2] = Math.sin(branchAngle + spinAngle) * radius + randomZ;

        const mixedColor = colorInside.clone().lerp(colorOutside, radius / galaxyParams.radius);
        colors[i3] = mixedColor.r;
        colors[i3 + 1] = mixedColor.g;
        colors[i3 + 2] = mixedColor.b;
    }

    galaxyGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    galaxyGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    galaxyMaterial = new THREE.PointsMaterial({ size: galaxyParams.size, sizeAttenuation: true, depthWrite: false, blending: THREE.AdditiveBlending, vertexColors: true });
    galaxyPoints = new THREE.Points(galaxyGeometry, galaxyMaterial);
    scene.add(galaxyPoints);
};
generateGalaxy();

// --- STARS ---
const starsGeometry = new THREE.BufferGeometry();
const starsCount = 5000;
const positionsStars = new Float32Array(starsCount * 3);
for (let i = 0; i < starsCount * 3; i++) positionsStars[i] = (Math.random() - 0.5) * 100;
starsGeometry.setAttribute('position', new THREE.BufferAttribute(positionsStars, 3));
const starsMaterial = new THREE.PointsMaterial({ size: 0.1, color: 0xffffff, transparent: true, opacity: 0.8 });
scene.add(new THREE.Points(starsGeometry, starsMaterial));

// --- FLOATING TEXTS ---
function createTextTexture(message, color, isHeart) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fontSize = isHeart ? 120 : 60;
    canvas.width = isHeart ? 300 : 1000;
    canvas.height = 300;
    ctx.font = `Bold ${fontSize}px ${isHeart ? 'serif' : FONT_FAMILY}`;
    ctx.fillStyle = color;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = color;
    ctx.shadowBlur = 30;
    ctx.fillText(message, canvas.width / 2, canvas.height / 2);
    return new THREE.CanvasTexture(canvas);
}

const floatingTexts = [];
for (let i = 0; i < PARTICLE_COUNT; i++) {
    const item = messages[Math.floor(Math.random() * messages.length)];
    const material = new THREE.SpriteMaterial({
        map: createTextTexture(item.text, item.color, item.isHeart),
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending
    });
    const sprite = new THREE.Sprite(material);
    const scaleFactor = item.size * 3;
    const aspectRatio = item.isHeart ? 1 : 3.5;
    sprite.scale.set(aspectRatio * scaleFactor, scaleFactor, 1);
    const radius = 8 + Math.random() * 20;
    const angle = Math.random() * Math.PI * 2;
    const y = (Math.random() - 0.5) * 15;
    const speed = (0.2 + Math.random() * 0.5) * (Math.random() < 0.5 ? 1 : -1) * 0.02;
    sprite.userData = { radius, angle, y, speed, baseOpacity: 0.5 + Math.random() * 0.5 };
    scene.add(sprite);
    floatingTexts.push(sprite);
}

const clock = new THREE.Clock();

// --- ANIMATE ---
const animate = () => {
    requestAnimationFrame(animate);
    const elapsed = clock.getElapsedTime();

    if (galaxyPoints) galaxyPoints.rotation.y = elapsed * 0.05;

    floatingTexts.forEach(s => {
        const blink = Math.sin(elapsed * 5 + s.userData.angle * 2) * 0.2 + 0.8;
        s.material.opacity = s.userData.baseOpacity * blink;
        s.userData.angle += s.userData.speed;
        s.position.x = Math.cos(s.userData.angle) * s.userData.radius;
        s.position.z = Math.sin(s.userData.angle) * s.userData.radius;
        s.position.y = s.userData.y + Math.sin(elapsed * 0.5 + s.userData.angle);
    });

    controls.update();
    renderer.render(scene, camera);
};
animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
